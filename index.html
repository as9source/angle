import React, { useState, useRef, useEffect } from 'react';

// 指示反映版：
//  - サッシより下に垂木掛けが行くことは「ない」前提 → サッシ関連寸法は表示しない
//  - 母屋屋根がアルミテラスに干渉している場合は「干渉中」とだけ表示（数値は出さない）
//  - 母屋屋根が上にある時（= クリアランス >= 0）のみ、数値を明記
//  - 図では「母屋屋根 ↔ 垂木上端（@x=D）」の寸法線のみ描画
//  - S(水平破線)とD(垂直破線)のガイドは残す

export default function App() {
  // 入力値
  const [L, setL] = useState(350);      // 母屋屋根の斜め寸法 L（mm）
  const [D, setD] = useState(200);      // 母屋屋根の水平寸法 D（mm）
  const [S, setS] = useState(80);       // サッシ上端 → 軒天 S（mm）
  const [Hg, setHg] = useState(200);    // 垂木掛け 上端高さ（壁側, z=Hg）
  const [Hkake, setHkake] = useState(67); // 垂木掛け 厚み（下端 = Hg - Hkake）
  const [theta, setTheta] = useState(10);  // 角度（既定10°）

  const canvasRef = useRef(null);
  const [summaryHTML, setSummaryHTML] = useState('');

  useEffect(() => { draw(); }, [L, D, S, Hg, Hkake, theta]);

  const rad = (d) => d * Math.PI / 180;
  const tan = (d) => Math.tan(rad(d));

  function draw(){
    const cv = canvasRef.current;
    const ctx = cv.getContext('2d');
    ctx.clearRect(0,0,cv.width,cv.height);

    // 入力チェック
    if(!isFinite(L) || !isFinite(D) || !isFinite(S) || !isFinite(Hg) || !isFinite(Hkake) || !isFinite(theta)) return;
    if(L < D) {
      setSummaryHTML(`<div style='color:#dc2626;font-weight:700'>エラー: L は D 以上にしてください。</div>`);
      return;
    }

    // 幾何
    const Zh = Math.sqrt(Math.max(0, L*L - D*D));        // 母屋屋根の高さ（@x=D）
    const tanv = tan(theta);
    const z_t = (x) => Hg + x * tanv;                    // 垂木 上端
    const z_kake_bottom = (x) => (Hg - Hkake) + x * tanv;// 垂木掛け 下端（参照）

    // 判定対象（母屋のみ）
    const diffMother = Zh - z_t(D);            // 母屋屋根（上） - 垂木上端（@D）

    // スケール計算
    const W=cv.width, H=cv.height, m=36;
    const Xmax = Math.max(D, 600);
    const Zmax = Math.max(S, Zh, z_t(D), z_kake_bottom(0), z_kake_bottom(D)) * 1.25 + 20;
    const sx = (W - 2*m) / (Xmax || 1);
    const sz = (H - 2*m) / (Zmax || 1);
    const X = (x) => m + x*sx;
    const Y = (z) => m + z*sz; // 下向きが＋

    // === ガイド ===
    // 軒天 z=0（基準）
    ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(m, Y(0)); ctx.lineTo(W-m, Y(0)); ctx.stroke();
    // 外壁 x=0（基準）
    ctx.beginPath(); ctx.moveTo(X(0), m); ctx.lineTo(X(0), H-m); ctx.stroke();

    // サッシ上端 S の水平破線（ガイドのみ）
    ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = '#2563eb';
    ctx.beginPath(); ctx.moveTo(X(0), Y(S)); ctx.lineTo(W-m, Y(S)); ctx.stroke(); ctx.restore();
    ctx.fillStyle = '#2563eb'; ctx.fillText(`サッシ上端 S=${S.toFixed(0)}mm`, X(8), Y(S)-6);

    // x = D の垂直破線
    ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = '#0ea5e9';
    ctx.beginPath(); ctx.moveTo(X(D), m); ctx.lineTo(X(D), H-m); ctx.stroke(); ctx.restore();
    ctx.fillStyle = '#0ea5e9'; ctx.fillText(`D=${D.toFixed(0)}mm`, X(D)+6, Y(0)-6);

    // === 形状 ===
    // 垂木 上端（濃緑）
    ctx.strokeStyle = '#15803d'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(X(0), Y(z_t(0))); ctx.lineTo(X(Xmax), Y(z_t(Xmax))); ctx.stroke();
    // 垂木掛け 下端（明緑）
    ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(X(0), Y(z_kake_bottom(0))); ctx.lineTo(X(Xmax), Y(z_kake_bottom(Xmax))); ctx.stroke();

    // 母屋屋根（赤）: 点(D, Zh)を通る直線（近傍だけ）
    const slope = D>0 ? (Zh/D) : Math.tan(Math.PI/3);
    const x1 = Math.max(0, D - Xmax*0.6), x2 = Math.min(Xmax, D + Xmax*0.6);
    const z1 = Zh + (x1 - D) * slope; const z2 = Zh + (x2 - D) * slope;
    ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(X(x1), Y(z1)); ctx.lineTo(X(x2), Y(z2)); ctx.stroke();

    // === 寸法表示（母屋↔垂木上端のみ） ===
    const drawDim = (x_px, y1_px, y2_px, color, label) => {
      ctx.strokeStyle = color; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x_px, y1_px); ctx.lineTo(x_px, y2_px); ctx.stroke();
      // 矢印
      const arrow = (x,y,dir) => { const s=6; ctx.beginPath();
        if(dir==='up'){ ctx.moveTo(x-s,y+s); ctx.lineTo(x,y); ctx.lineTo(x+s,y+s); }
        else{ ctx.moveTo(x-s,y-s); ctx.lineTo(x,y); ctx.lineTo(x+s,y-s); }
        ctx.stroke(); };
      ctx.strokeStyle = color; arrow(x_px, y1_px, 'up'); arrow(x_px, y2_px, 'down');
      const tx = x_px + 8; const ty = (y1_px + y2_px)/2 + 4;
      const text = label; const w = ctx.measureText(text).width + 10;
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(tx-4, ty-14, w, 18);
      ctx.fillStyle = color; ctx.fillText(text, tx, ty);
    };

    // diffMother >= 0 のときだけ寸法線＆数値を描く
    if (diffMother >= 0) {
      drawDim(X(D)-40, Y(Zh), Y(z_t(D)), '#eab308', `母屋屋根↔垂木上端: ${(diffMother).toFixed(1)}mm`);
    }

    // === 結果（母屋のみ、10mmルール） ===
    const lines = [];
    if (diffMother < 0) {
      lines.push(`<div style='color:#dc2626;font-weight:700'>⚠ 母屋屋根がアルミテラスに干渉しています（数値表示なし）</div>`);
    } else if (diffMother < 10) {
      lines.push(`<div style='color:#d97706;font-weight:700'>⚠ クリアランス10mm未満（母屋側 ${diffMother.toFixed(1)}mm）</div>`);
    } else {
      lines.push(`<div style='color:#15803d;font-weight:700'>✅ クリアランスOK（母屋側 ${diffMother.toFixed(1)}mm）</div>`);
    }

    setSummaryHTML(lines.join(''));
  }

  return (
    <div style={{padding:16}}>
      <h2 style={{marginBottom:8}}>テラス屋根クリアランス（母屋屋根のみ表示）</h2>
      <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:12,alignItems:'start'}}>
        <div>
          <label>母屋の屋根の斜め寸法 L(mm): <input type="number" value={L} onChange={e=>setL(+e.target.value||0)} /></label>
          <label>母屋の屋根の水平寸法 D(mm): <input type="number" value={D} onChange={e=>setD(+e.target.value||0)} /></label>
          <label>サッシ上端→軒天 S(mm): <input type="number" value={S} onChange={e=>setS(+e.target.value||0)} /></label>
          <label>垂木掛け 上端高さ Hg(mm): <input type="number" value={Hg} onChange={e=>setHg(+e.target.value||0)} /></label>
          <label>垂木掛け 厚み Hkake(mm): <input type="number" value={Hkake} onChange={e=>setHkake(+e.target.value||0)} /></label>
          <label>角度 θ(°): <input type="number" value={theta} onChange={e=>setTheta(+e.target.value||0)} /></label>
        </div>
        <div>
          <canvas ref={canvasRef} width={760} height={420} style={{border:'1px solid #cbd5e1',borderRadius:8,background:'#fff'}} />
          <div style={{marginTop:10}} dangerouslySetInnerHTML={{__html: summaryHTML}} />
        </div>
      </div>
    </div>
  );
}
