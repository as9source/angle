import React, { useState, useRef, useEffect } from 'react';

// 最初から要件を読み直して作り直した、プレビュー対応の最終安定版です。
// 表示・判定の対象は次の2点のみ：
//  1) サッシ上端 → 垂木掛け下端（壁側 x=0）
//  2) 母屋屋根 ↔ 垂木上端（x=D）
// ・10mm未満は「危険域」表示、負値は「干渉」表示。
// ・D の位置は破線で可視化、サッシ上端 S は水平破線で可視化。
// ・角度は 10°固定（必要時のみ変更可）。

export default function App() {
  // 入力値
  const [L, setL] = useState(350);      // 母屋屋根の斜め寸法 L（mm）
  const [D, setD] = useState(200);      // 母屋屋根の水平寸法 D（mm）
  const [S, setS] = useState(80);       // サッシ上端 → 軒天 S（mm）
  const [Hg, setHg] = useState(200);    // 垂木掛け 上端高さ（壁側, z=Hg）
  const [Hkake, setHkake] = useState(67); // 垂木掛け 厚み（下端 = Hg - Hkake）
  const [theta, setTheta] = useState(10);  // 角度（既定10°）

  const canvasRef = useRef(null);
  const [summaryHTML, setSummaryHTML] = useState('');

  useEffect(() => { draw(); }, [L, D, S, Hg, Hkake, theta]);

  const rad = (d) => d * Math.PI / 180;
  const tan = (d) => Math.tan(rad(d));

  function draw(){
    const cv = canvasRef.current;
    const ctx = cv.getContext('2d');
    ctx.clearRect(0,0,cv.width,cv.height);

    // 入力チェック
    if(!isFinite(L) || !isFinite(D) || !isFinite(S) || !isFinite(Hg) || !isFinite(Hkake) || !isFinite(theta)) return;
    if(L < D) {
      setSummaryHTML(`<div style='color:#dc2626;font-weight:700'>エラー: L は D 以上にしてください。</div>`);
      return;
    }

    // 幾何
    const Zh = Math.sqrt(Math.max(0, L*L - D*D));        // 母屋屋根の高さ（@x=D）
    const tanv = tan(theta);
    const z_t = (x) => Hg + x * tanv;                    // 垂木 上端
    const z_kake_bottom = (x) => (Hg - Hkake) + x * tanv;// 垂木掛け 下端（参考：描画は壁側で寸法）

    // 判定対象の差分値（+は余裕、-は不足）
    const diffMother = Zh - z_t(D);            // 母屋屋根（上） - 垂木上端（@D）
    const diffSash   = (Hg - Hkake) - S;       // 垂木掛け下端（@0） - サッシ上端 S

    // スケール計算
    const W=cv.width, H=cv.height, m=36;
    const Xmax = Math.max(D, 600);
    const Zmax = Math.max(S, Zh, z_t(D), z_kake_bottom(0), z_kake_bottom(D)) * 1.25 + 20;
    const sx = (W - 2*m) / (Xmax || 1);
    const sz = (H - 2*m) / (Zmax || 1);
    const X = (x) => m + x*sx;
    const Y = (z) => m + z*sz; // 下向きが＋

    // === ガイド ===
    // 軒天 z=0（基準）
    ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(m, Y(0)); ctx.lineTo(W-m, Y(0)); ctx.stroke();
    // 外壁 x=0（基準）
    ctx.beginPath(); ctx.moveTo(X(0), m); ctx.lineTo(X(0), H-m); ctx.stroke();

    // サッシ上端 S の水平破線
    ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = '#2563eb';
    ctx.beginPath(); ctx.moveTo(X(0), Y(S)); ctx.lineTo(W-m, Y(S)); ctx.stroke(); ctx.restore();
    ctx.fillStyle = '#2563eb'; ctx.fillText(`サッシ上端 S=${S.toFixed(0)}mm`, X(8), Y(S)-6);

    // x = D の垂直破線
    ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = '#0ea5e9';
    ctx.beginPath(); ctx.moveTo(X(D), m); ctx.lineTo(X(D), H-m); ctx.stroke(); ctx.restore();
    ctx.fillStyle = '#0ea5e9'; ctx.fillText(`D=${D.toFixed(0)}mm`, X(D)+6, Y(0)-6);

    // === 形状 ===
    // 垂木 上端（濃緑）
    ctx.strokeStyle = '#15803d'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(X(0), Y(z_t(0))); ctx.lineTo(X(Xmax), Y(z_t(Xmax))); ctx.stroke();
    // 垂木掛け 下端（明緑）
    ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(X(0), Y(z_kake_bottom(0))); ctx.lineTo(X(Xmax), Y(z_kake_bottom(Xmax))); ctx.stroke();

    // 母屋屋根（赤）: 点(D, Zh)を通る直線（近傍だけ）
    const slope = D>0 ? (Zh/D) : Math.tan(Math.PI/3);
    const x1 = Math.max(0, D - Xmax*0.6), x2 = Math.min(Xmax, D + Xmax*0.6);
    const z1 = Zh + (x1 - D) * slope; const z2 = Zh + (x2 - D) * slope;
    ctx.strokeStyle = '#dc2626'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(X(x1), Y(z1)); ctx.lineTo(X(x2), Y(z2)); ctx.stroke();

    // === 寸法表示 ===
    const drawDim = (x_px, y1_px, y2_px, color, label) => {
      ctx.strokeStyle = color; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x_px, y1_px); ctx.lineTo(x_px, y2_px); ctx.stroke();
      // 矢印
      const arrow = (x,y,dir) => { const s=6; ctx.beginPath();
        if(dir==='up'){ ctx.moveTo(x-s,y+s); ctx.lineTo(x,y); ctx.lineTo(x+s,y+s); }
        else{ ctx.moveTo(x-s,y-s); ctx.lineTo(x,y); ctx.lineTo(x+s,y-s); }
        ctx.stroke(); };
      ctx.strokeStyle = color; arrow(x_px, y1_px, 'up'); arrow(x_px, y2_px, 'down');
      const tx = x_px + 8; const ty = (y1_px + y2_px)/2 + 4;
      // 背景
      const text = label; const w = ctx.measureText(text).width + 10;
      ctx.fillStyle = color.replace('1)', '0.12)').replace(')', '') || 'rgba(0,0,0,0.08)';
      // 安全な背景色に変更
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(tx-4, ty-14, w, 18);
      ctx.fillStyle = color; ctx.fillText(text, tx, ty);
    };

    // 1) サッシ上端 → 垂木掛け下端（壁側）
    drawDim(X(0)+40, Y(S), Y(Hg - Hkake), '#0284c7', `サッシ上端→垂木掛け下端: ${(diffSash).toFixed(1)}mm`);

    // 2) 母屋屋根 ↔ 垂木上端（@x=D）
    drawDim(X(D)-40, Y(Zh), Y(z_t(D)), '#eab308', `母屋屋根↔垂木上端: ${(diffMother).toFixed(1)}mm`);

    // === 結果（10mmルール） ===
    const lines = [];
    lines.push(`<div>母屋屋根↔垂木上端（@x=D）: <b>${diffMother.toFixed(1)}mm</b></div>`);
    lines.push(`<div>サッシ上端→垂木掛け下端（壁側）: <b>${diffSash.toFixed(1)}mm</b></div>`);

    const warnMother = diffMother < 10 && diffMother >= 0;
    const errMother  = diffMother < 0;
    const warnSash   = diffSash < 10 && diffSash >= 0;
    const errSash    = diffSash < 0;

    if(errMother) lines.push(`<div style='color:#dc2626;font-weight:700'>⚠ 母屋側 干渉（不足 ${Math.abs(diffMother).toFixed(1)}mm）</div>`);
    else if(warnMother) lines.push(`<div style='color:#d97706;font-weight:700'>⚠ 母屋側 クリアランス10mm未満（${diffMother.toFixed(1)}mm）</div>`);

    if(errSash) lines.push(`<div style='color:#dc2626;font-weight:700'>⚠ サッシ側 干渉（垂木掛け下端が上に ${Math.abs(diffSash).toFixed(1)}mm）</div>`);
    else if(warnSash) lines.push(`<div style='color:#d97706;font-weight:700'>⚠ サッシ側 クリアランス10mm未満（${diffSash.toFixed(1)}mm）</div>`);

    if(!errMother && !warnMother && !errSash && !warnSash){
      lines.push(`<div style='color:#15803d;font-weight:700'>✅ クリアランスOK（両側とも ≥10mm）</div>`);
    }

    setSummaryHTML(lines.join(''));
  }

  return (
    <div style={{padding:16}}>
      <h2 style={{marginBottom:8}}>テラス屋根クリアランス（垂木掛け下端／母屋屋根）</h2>
      <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:12,alignItems:'start'}}>
        <div>
          <label>母屋の屋根の斜め寸法 L(mm): <input type="number" value={L} onChange={e=>setL(+e.target.value||0)} /></label>
          <label>母屋の屋根の水平寸法 D(mm): <input type="number" value={D} onChange={e=>setD(+e.target.value||0)} /></label>
          <label>サッシ上端→軒天 S(mm): <input type="number" value={S} onChange={e=>setS(+e.target.value||0)} /></label>
          <label>垂木掛け 上端高さ Hg(mm): <input type="number" value={Hg} onChange={e=>setHg(+e.target.value||0)} /></label>
          <label>垂木掛け 厚み Hkake(mm): <input type="number" value={Hkake} onChange={e=>setHkake(+e.target.value||0)} /></label>
          <label>角度 θ(°): <input type="number" value={theta} onChange={e=>setTheta(+e.target.value||0)} /></label>
        </div>
        <div>
          <canvas ref={canvasRef} width={760} height={420} style={{border:'1px solid #cbd5e1',borderRadius:8,background:'#fff'}} />
          <div style={{marginTop:10}} dangerouslySetInnerHTML={{__html: summaryHTML}} />
        </div>
      </div>
    </div>
  );
}
